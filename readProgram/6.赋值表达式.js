var a = {
  n: 1
};
var b = a;
a.x = a = {
  n: 2
};
console.log(a.x)
console.log(b.x)
/*这一行比较复杂。先获取等号左侧的a.x，但a.x并不存在，于是JS为（堆内存中的）对象创建一个新成员x，这个成员的初始值为undefined，（这也是为什么直接引用一个未定义的变量会报错，但是直接引用一个对象的不存在的成员时，会返回undefined.）创建完成后，目标指针已经指向了这个新成员x，并会先挂起，单等等号右侧的内容有结果了，便完成赋值。接着执行赋值语句的右侧，发现a={n:2}是个简单的赋值操作，于是a的新值等于了{n:2}。这里特别注意，这个a已经不是开头的那个a，而是一个全新的a,这个新a指针已经不是指向原来的值的那个堆内存，而是分配了一个新的堆内存。但是原来旧的堆内存因为还有b在占用，所以并未被回收。然后，将这个新的对象a的堆内存指针，赋值给了刚才挂起的新成员x,此时，对象成员x便等于了新的对象a。所以，现在b={n:1,x:{n:2}};a={n:2};a===b.x(true,注意对象的相等，不是值的相等，而是引用的相等，也就是说，相等表示指针是指向同一个堆内存。)  */
